(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{"9WoF":function(e,n,r){(window.__NEXT_P=window.__NEXT_P||[]).push(["/docs/gettingstarted/codewalkthrough",function(){var e=r("iseh");return{page:e.default||e}}])},iseh:function(e,n,r){"use strict";r.r(n);var t=r("q1tI"),a=r.n(t),s=r("HVSj"),i=r("pIOD");n.default=function(e){return a.a.createElement(s.a,{content:i.a})}},pIOD:function(e,n,r){"use strict";n.a="## Constructor\n\n| Returned from   | Type   | Description                                                                                                                     |\n| --------------- | ------ | ------------------------------------------------------------------------------------------------------------------------------- |\n| `Firecomm.Stub` | Object | The `Stub` constructor generates an instance of Firecomm's `Stub` class, which extends the native gRPC client-service instance. |\n\n# Getting Started\n## Install\n``` \nnpm i --save firecomm\n```\n\n## 1. Define a `.proto` file\nLet's begin by creating a file named `exampleAPI.proto` that will live inside a `proto` folder. The `ProtoBuf` we define in this file will define the name of the `package`, the names of the `service`s, the `rpc` methods, what the client `Stub` sends, what the `Server` returns, and the structured data that is part of each `message`.\n\n```protobuf\n// proto/exampleAPI.proto\nsyntax proto3\n\npackage exampleAPI\n\nservice FileTransfer {\n  rpc ClientToServer (stream File) returns (Confirmation) {};\n  rpc ServerToClient (Confirmation) returns (stream File) {};\n}\n\nservice HeavyMath {\n  rpc UnaryMath (Math) returns (Math) {};\n  rpc BidiMath (stream Math) returns (stream Math) {};\n}\n\nmessage Confirmation {\n  bool status = 1;\n  string comments = 2;\n}\n\nmessage File {\n  bytes fileBuffer = 1;\n}\n\nmessage Math {\n  double num = 1;\n}\n```\n\n> Each `rpc` Method clearly defines request/response, client `Stub` to `Server` regardless of call type. For example:\n> ```protobuf\n> //    MethodName    Stub/request         Server/response\n> rpc ClientToServer (stream File) returns (Confirmation) {};\n> ```\n\n## 2. Let's `build()` a `package`\n\nNow that we've defined our API in a ProtoBuf, let's pass an absolute path to our `.proto` file to build a `package`. We will create a `package.js` file which will live in our root folder and `export` a configured `package` containing the transpiled `service`s and `rpc` methods.\n\nWe will also define our configuration for how our packaged methods will handle different data types.\n\n```javascript\n// package.js\nconst { build } = require( 'firecomm' );\nconst path = require( 'path' );\nconst PROTO_PATH = path.join( __dirname, './proto/exampleAPI.proto' );\n\nconst CONFIG_OBJECT = {\n  keepCase: true, // keeps everything camelCased\n  longs: Number, // transpiles the enormous `double`s for our HeavyMath into a javascript Number rather than a String\n  bytes: String, // helps us manage the FileTransfer bytes as javascript `String`s rather than pure hexadecimal Buffers or uint8Arrays\n}\nconst package = build( PROTO_PATH, CONFIG_OBJECT );\nmodule.exports = package;\n```\n\n> Advanced Note: whether you're building a firecomm/gRPC-Node `Server`, a firecomm/gRPC-Node client with `Stub`s, or a firecomm/gRPC-Node hybrid client/server, it is important to build a package with configurations that match the API for your distributed system. Every server and client should have the same `.proto` file regardless of language.\n\n## 3. Create a server\nNext, we will create a `new Server()` inside a `server.js` file which will live in a `server` folder. \n\n```javascript\n// /server/server.js\nconst { Server } = require( 'firecomm' );\nconst server = new Server();\n```\n## 4. Define the server-side handlers for our `FileTransfer` service.\n\nLet's define handler functions for our two `FileTransfer` `rpc` methods. Method handler functions will contain the server-side logic for our `service`s. Let's create a `fileTransferHandlers.js` file which will live inside our `server` folder.\n\n```javascript\n// /server/fileTransferHandlers.js\nClientToServerHandler( CALL ) {\n  CALL.send({ response: value });\n};\nServerToClientHandler( CALL ) {\n  CALL.on('data', request => someFunctionality(request));\n  CALL.send({ response: value });\n};\nmodule.exports = { \n\tClientToServerHandler,\n\tServerToClientHandler,\n}\n```\n\n## 5. Define the server-side handlers for our `HeavyMath` service.\n\nLet's define handler functions for our two HeavyMath methods. Let's continue by defining the handlers for our `HeavyMath` service in a `heavyMathHandlers.js` file which will live inside our `server` folder.\n\n```javascript\n// /server/heavyMathHandlers.js\nUnaryMathHandler( CALL ) {\n  CALL.send({ response: value });\n};\nBidiMathHandler( CALL ) {\n  CALL.on('data', request => someFunctionality(request));\n  CALL.send({ response: value });\n};\nmodule.exports = { \n\tUnaryMathHandler,\n\tBidiMathHandler,\n}\n```\n\n## 6. Add each `service` from the package to the `Server`\n\nLet's now return to the `server.js` file and map each `service` onto our `Server`. Mirroring the structure of the `.proto` file we transpiled, the `package` object we built has both of the `service`s on it as properties. We use the `Server` method `.addService` to add the `services` one at a time and map each of the `rpc` methods to the handlers we wrote.  \n\n```javascript\n// /server/server.js\nconst { Server } = require( 'firecomm' );\nconst package = require( '../package.js' );\nconst { ClientToServerHandler,\n\tServerToClientHandler } = require ( './fileTransferHandlers.js );\nconst { UnaryMathHandler,\n\tBidiMathHandler } = require ( './heavyMathHandlers.js );\n\nconst server = new Server();\nserver.addService( package.FileTransfer,   { \n  ClientToServer: ClientToServerHandler,\n  ServerToClient: ServerToClientHandler,\n });\n server.addService( package.HeavyMath,   { \n  UnaryMath: UnaryMathHandler,\n  BidiMath: BidiMathHandler,\n });\n```\n> Note: The `Server.addService()` method also allows the mapping of middleware functions or a middleware stack of functions in the form of an `array` to be passed in order to influence `rpc` methods before the handler which should come last in the array. For example: \n> ```javascript\n> server.addService( package.HeavyMath,   > { \n>   UnaryMath: [ UnaryMathMiddleware, UnaryMathHandler ],\n>   BidiMath: ServerToClientHandler,\n> }, [ serviceLevelMiddleware1, serviceLevelMiddleware2 ]);\n> ```\n\n## 7. Bind the server to `socket`(s)\n\n```javascript\n// /server/server.js\nconst { Server } = require( 'firecomm' );\nconst package = require( '../package.js' );\nconst { ClientToServerHandler,\n\tServerToClientHandler } = require ( './fileTransferHandlers.js );\nconst { UnaryMathHandler,\n\tBidiMathHandler } = require ( './heavyMathHandlers.js );\n\nconst server = new Server();\nserver.addService( package.FileTransfer,   { \n  ClientToServer: ClientToServerHandler,\n  ServerToClient: ServerToClientHandler,\n });\n server.addService( package.HeavyMath,   { \n  UnaryMath: UnaryMathHandler,\n  BidiMath: BidiMathHandler,\n });\nserver.bind('0.0.0.0: 3000');\n```\n> Note: `Server`s can be passed an array of `socket`s to bind any number of `socket`s. For example:\n> ```javascript\n> server.bind( [ \n>   '0.0.0.0: 3000', \n>   '0.0.0.0: 2999', \n> ] );\n> ```\n## 8. Start the server\n```javascript\n// /server/server.js\nconst { Server } = require( 'firecomm' );\nconst package = require( '../package.js' );\nconst { ClientToServerHandler,\n\tServerToClientHandler } = require ( './fileTransferHandlers.js );\nconst { UnaryMathHandler,\n\tBidiMathHandler } = require ( './heavyMathHandlers.js );\n\nconst server = new Server();\nserver.addService( package.FileTransfer,   { \n  ClientToServer: ClientToServerHandler,\n  ServerToClient: ServerToClientHandler,\n });\n server.addService( package.HeavyMath,   { \n  UnaryMath: UnaryMathHandler,\n  BidiMath: BidiMathHandler,\n });\nserver.bind( [ \n  '0.0.0.0: 3000', \n  '0.0.0.0: 2999', \n] );\nserver.start();\n```\n> Run your new firecomm/gRPC-Node server with: `node /server/server.js`. It may also be worthwhile to map this command to `npm start` in your `package.json`.\n## 9.  Create a `Stub` for the `FileTransfer` service:\nNow that the `Server` is fully fleshed out, let's move to the client side by creating a client with `Stub`s for each `rpc` method on `FileTransfer`. Let's create a `fileTransferClient.js` file which will live inside our `clients` folder.\n```javascript\n// /clients/fileTransfer.js\nconst { Stub } = require( 'firecomm' );\nconst package = require( '../package.js' )\nconst fileTransferStub = new Stub( \n\tpackage.FileTransfer, \n\t'localhost: 3000',\n);\n```\n> In a real gRPC distributed system with firecomm/gRPC-Node clients, each client will most likely exist separately for each `service` defined in the shared `.proto` file. However, clients can actually have any number of `Stubs` running on them on either the same `socket` or multiple `sockets`. Additionally, duplicate clients running the same service(s) can be used to allow server level load-balancing.\n## 10.  Make `ClientToServer` and `ServerToClient` service requests from the `Stub`\n\n```javascript\n// /clients/fileTransfer.js\nconst { Stub } = require( 'firecomm' );\nconst package = require( '../package.js' )\nconst fileTransferStub = new Stub( \n\tpackage.FileTransfer, \n\t'localhost: 3000',\n);\nconst clientStream = \n  fileTransferStub.ClientToServer( MESSAGE );\n  // some logic to warrant a streaming response\n  clientStream.write( MESSAGE );\nconst serverStream = \n  fileTransferStub.ServerToClient( MESSAGE );\n  // listeners for stream from server\n  serverStream.on( 'data', response => \n  someFunctionality(request));\n```\n> Run your new firecomm/gRPC-Node client with: `node /clients/fileTransfer.js`. It may also be worthwhile to map this command to a custom command like `npm run transfer` in your `package.json`.\n\n## 11.  Create a `Stub` for the `HeavyMath` service:\nNow that the `Server` and `FileTransfer` Stub are fully fleshed out, let's create another `Stub` with access to each `rpc` method on `HeavyMath`. We'll create a `heavyMath.js` file which will live inside our `clients` folder.\n```javascript\n// /clients/heavyMath.js\nconst { Stub } = require( 'firecomm' );\nconst package = require( '../package.js' )\nconst heavyMathStub = new Stub( \n\tpackage.HeavyMath, \n\t'localhost: 2999',\n);\n```\n> Note: two different clients *can* share a single socket on the server, in which case all concurrent requests and responses will be multiplexed. However, in a real gRPC distributed system, this is unlikely for two different services to share a socket.\n\n## 12. Make `UnaryMath` and `BidiMath` service requests from the `Stub`\n```javascript\n// /clients/heavyMath.js\nconst { Stub } = require( 'firecomm' );\nconst package = require( '../package.js' )\nconst heavyMathStub = new Stub( \n\tpackage.HeavyMath, \n\t'localhost: 2999',\n);\nheavyMathStub.UnaryMath( MESSAGE );\n  // some logic to warrant a streaming response\n  clientStream.write( MESSAGE );\nconst bidiStream = \n  heavyMathStub.BidiMath( MESSAGE );\n  // listeners for stream from server\n  serverStream.on( 'data', response => \n  someFunctionality(request));\n```\n> Run your new firecomm/gRPC-Node client with: `node /clients/heavyMath.js`. It may also be worthwhile to map this command to a custom command like `npm run math` in your `package.json`."}},[["9WoF",1,0]]]);